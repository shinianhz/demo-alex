<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trae.ai Style Canvas Particle Network</title>
    <style>
        /* 基础样式设置，确保 Canvas 占满屏幕且背景为深色 */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0a0a0a; /* 接近 trae.ai 的深色背景 */
        }
        canvas {
            display: block;
            /* 确保 canvas 在最底层 */
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
    </style>
</head>
<body>

<canvas id="particle-canvas"></canvas>

<script>
    const canvas = document.getElementById('particle-canvas');
    const ctx = canvas.getContext('2d');

    let w, h;
    let particlesArray;

    // 配置参数 - 你可以调整这里来改变效果
    const config = {
        particleColor: 'rgba(173, 216, 230, 1)', // 浅蓝色粒子
        lineColor: '173, 216, 230', // 连线的 RGB 值 (不带 alpha)
        particleAmount: 100,         // 屏幕上的粒子数量
        defaultSpeed: 0.5,           // 粒子运动速度
        variantSpeed: 1,             // 速度的随机变化范围
        defaultRadius: 2,            // 粒子半径
        variantRadius: 2,            // 半径的随机变化范围
        linkRadius: 120,             // 粒子之间连接的最大距离
        mouseLinkRadius: 150         // 鼠标与粒子连接的最大距离
    };

    // 鼠标交互对象
    let mouse = {
        x: null,
        y: null,
        radius: config.mouseLinkRadius
    }

    // 监听鼠标移动
    window.addEventListener('mousemove', function(e) {
        mouse.x = e.x;
        mouse.y = e.y;
    });

    // 监听鼠标离开屏幕，重置鼠标位置，避免连线粘滞在边缘
    window.addEventListener('mouseout', function() {
        mouse.x = undefined;
        mouse.y = undefined;
    })

    // 设置 Canvas 尺寸
    function setCanvasSize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
    }

    // 粒子类
    class Particle {
        constructor(x, y) {
            // 如果传入了特定位置就用特定的，否则随机生成
            this.x = x || Math.random() * canvas.width;
            this.y = y || Math.random() * canvas.height;
            // 随机方向向量 (速度)
            this.directionX = (Math.random() * config.variantSpeed) - (config.variantSpeed / 2) + config.defaultSpeed * (Math.random() > 0.5 ? 1 : -1);
            this.directionY = (Math.random() * config.variantSpeed) - (config.variantSpeed / 2) + config.defaultSpeed * (Math.random() > 0.5 ? 1 : -1);
            // 随机大小
            this.size = Math.random() * config.variantRadius + config.defaultRadius;
        }

        // 绘制单个粒子
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fillStyle = config.particleColor;
            ctx.fill();
        }

        // 更新粒子位置
        update() {
            // 边界检测：碰到屏幕边缘则反弹
            if (this.x > canvas.width || this.x < 0) {
                this.directionX = -this.directionX;
            }
            if (this.y > canvas.height || this.y < 0) {
                this.directionY = -this.directionY;
            }
            // 移动位置
            this.x += this.directionX;
            this.y += this.directionY;
            // 绘制
            this.draw();
        }
    }

    // 初始化场景
    function init() {
        setCanvasSize();
        particlesArray = [];
        // 根据屏幕大小动态调整粒子数量 (可选，这里使用固定数量)
        // let numberOfParticles = (canvas.height * canvas.width) / 9000;
        for (let i = 0; i < config.particleAmount; i++) {
            particlesArray.push(new Particle());
        }
    }

    // 连接粒子
    function connect() {
        let opacityValue = 1;
        for (let a = 0; a < particlesArray.length; a++) {
            // 1. 粒子与粒子之间的连线检测
            for (let b = a + 1; b < particlesArray.length; b++) { // 从 a+1 开始，避免重复计算和自身比较
                let dx = particlesArray[a].x - particlesArray[b].x;
                let dy = particlesArray[a].y - particlesArray[b].y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < config.linkRadius) {
                    // 距离越远，透明度越低
                    opacityValue = 1 - (distance / config.linkRadius);
                    ctx.strokeStyle = 'rgba(' + config.lineColor + ',' + opacityValue + ')';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                    ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                    ctx.stroke();
                }
            }

            // 2. 粒子与鼠标之间的连线检测
            if (mouse.x && mouse.y) {
                let mdx = particlesArray[a].x - mouse.x;
                let mdy = particlesArray[a].y - mouse.y;
                let mouseDistance = Math.sqrt(mdx * mdx + mdy * mdy);
                if (mouseDistance < config.mouseLinkRadius) {
                     // 鼠标连线稍微亮一点
                    opacityValue = 1 - (mouseDistance / config.mouseLinkRadius);
                    ctx.strokeStyle = 'rgba(' + config.lineColor + ',' + opacityValue + ')';
                    ctx.lineWidth = 0.8; // 鼠标连线稍微粗一点点
                    ctx.beginPath();
                    ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                    ctx.lineTo(mouse.x, mouse.y);
                    ctx.stroke();
                }
            }
        }
    }

    // 动画循环
    function animate() {
        requestAnimationFrame(animate);
        // 每一帧清空画布
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 更新所有粒子
        for (let i = 0; i < particlesArray.length; i++) {
            particlesArray[i].update();
        }
        // 绘制连线（注意：connect 最好在 update 之后调用，这样连线在点之上，或者反过来，看你喜欢哪种效果）
        connect();
    }

    // 监听窗口大小改变
    window.addEventListener('resize', function() {
        setCanvasSize();
        init(); // 重新初始化粒子以适应新窗口
    });


    // 启动
    init();
    animate();

</script>

</body>
</html>
